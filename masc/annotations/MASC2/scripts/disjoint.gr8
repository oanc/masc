/*
 * Compares one or more annotation types and ensures that no two
 * annotations overlap. This is intended to compare disjoint
 * annotation types (ie nouns and verbs) to ensure there are
 * no overlaps.
 *
 * The algorithm is simple, add all annotations to a list and sort
 * by their start offset. If any annotations overlap then for some
 * pair of consecutive annotions L[i] and L[i+1] in the list the
 * following must hold:
 *     L[i].end >= L[i+1].start
 *
 * USAGE: grate disjoint.gr8 /path/to/corpus nc vc
 */
import gate.Document
import gate.Factory
import gate.AnnotationSet
import gate.Annotation

String getText(String content, Annotation a)
{
	int start = a.startNode.offset.intValue()
	int end = a.endNode.offset.intValue()
	return content[start..end-1]
}

File getStandoff(File file, String type)
{
	String basename = file.name[0..-5]
	File parent = file.getParentFile()
	String soName = "${basename}-${type}.xml"
	return new File(parent, soName)
}

int countOverlaps(Document doc, String setName)
{
	String content = doc.getContent().toString()
	AnnotationSet aset = doc.getAnnotations(setName)
	if (aset.size() == 0)
	{
		return 0
	}
	List list = []
	aset.each { a ->
		if (a.type != 'tok')
		{
			list << a
		}
	}
	def comparator = new gate.util.OffsetComparator()
	int count = 0

	Collections.sort(list, comparator)
	Iterator it = list.iterator()
	def previous = it.next()
	while (it.hasNext())
	{
		def current = it.next()
		if (previous.type != current.type && current.startNode.offset.intValue() < previous.endNode.offset.intValue())
		{
			++count
			
			String span1 = getText(content, previous)
			String span2 = getText(content, current)
			println "Overlap: ${previous.type} with ${current.type}"
			println "    ${previous.startNode.offset} ${span1}"
			println "    ${current.startNode.offset} ${span2}"
			
			++count
		}
		previous = current
	}
	return count
}

if (this.args.size() < 2)
{
	println "USAGE: grate disjoint.gr8 <path> <type> [<type> ...]"
	return
}

final String SET_NAME = 'Standoff'

String path = this.args[0]
File file = new File(path)
if (!file.exists())
{
	println "Input file/directory not found."
	return
}

def loadPR = newResource('org.anc.gate.LoadGrafStandoff') {
	standoffASName(SET_NAME)
}

def q = []
q << file
while (q.size())
{
	file = q.remove(0)
	if (file.isDirectory())
	{
		println "Processing ${file.path}"
		file.listFiles().each {
			if (it.isDirectory() || it.name.endsWith('.txt'))
			{
				q << it
			}
		}
	}
	else
	{
		println "Processing text file ${file.name}"
		Document doc = newDocument(file)
		loadPR.document = doc
		int i = 1
		for (; i < this.args.size(); ++i)
		{
			String type = this.args[i]
			File soFile = getStandoff(file, type)
			if (soFile.exists())
			{
				loadPR.sourceUrl = soFile.toURI().toURL()
				loadPR.execute()
			}
			else
			{
				println "Standoff annotation file ${soFile.name} not found."
			}
		}

		if (i > 1)
		{
			int count = countOverlaps(doc, SET_NAME)
			if (count > 0)
			{
				println "${file.name}: Found ${count} overlapping annotations."
			}
		}
	}
}
println "Done."